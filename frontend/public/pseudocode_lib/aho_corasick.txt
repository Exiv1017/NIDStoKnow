BUILD_AUTOMATON(patterns):
  - root := new node (next={}, fail=root, output=[])
  - insert each pattern into trie; append pattern to node.output at pattern end
  - BFS over root.next: set child.fail := root for root children
  - For each dequeued node r and edge ch->u:
      - f := r.fail; walk f via fail links until f.next contains ch or f==root
      - set u.fail := f.next[ch] if present else root
      - u.output += u.fail.output  // inherit suffix matches
  - return root

AC_SEARCH(root, text):
  - node := root; matches := []
  - for i,ch in enumerate(text):
      - while node != root and ch not in node.next: node := node.fail
      - node := node.next[ch] if ch in node.next else root
      - for pat in node.output: append (i-len(pat)+1, i, pat) to matches
  - return matches

Complexity: O(sum |patterns|) build, O(|text| + matches) search.
Notes: outputs can be deduplicated with a set; use hash maps for sparse alphabets.

